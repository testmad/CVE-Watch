'use strict'

import { app, protocol, BrowserWindow, ipcMain, dialog } from 'electron'
import {
  createProtocol,
  installVueDevtools
} from 'vue-cli-plugin-electron-builder/lib'
const isDevelopment = process.env.NODE_ENV !== 'production'

const fs = require('fs')
const request = require('request')

var internetAvailable = require('internet-available')

// get rid of this in next version as using vuex is possible
const Store = require('electron-store')
const store = new Store()

const firstline = require('firstline')
const zlib = require('zlib')

import {parse} from 'node-html-parser'

var saxpath = require('saxpath')
var sax     = require('sax');

var xml2js = require('xml2js')

// uninstall at some point
//var JSONStream = require( "JSONStream" );

// disable gpu
//app.disableHardwareAcceleration()

// Keep a global reference of the window object, if you don't, the window will
// be closed automatically when the JavaScript object is garbage collected.
let win

// Standard scheme must be registered before the app is ready
protocol.registerStandardSchemes(['app'], { secure: true })
function createWindow () {
  // Create the browser window.
  win = new BrowserWindow({ width: 900, height: 780, backgroundColor: '#202428', minWidth: 840, minHeight: 780 })

  if (isDevelopment || process.env.IS_TEST) {
    // Load the url of the dev server if in development mode
    win.loadURL(process.env.WEBPACK_DEV_SERVER_URL)
    if (!process.env.IS_TEST) win.webContents.openDevTools()
  } else {
    createProtocol('app')
    // Load the index.html when not in development
    win.loadURL('app://./index.html')
  }

  win.on('closed', () => {
    win = null
  })

  if(!store.has('version')) {
    store.set("version", "0.0.1");

    store.set("nvd.meta_url", "https://nvd.nist.gov/feeds/json/cve/1.0/nvdcve-1.0-recent.meta");
    store.set("nvd.data_url", "https://nvd.nist.gov/feeds/json/cve/1.0/nvdcve-1.0-recent.json.gz");
    store.set("nvd.last_update", "");

    store.set("mitre.data_url", "https://nvd.nist.gov/feeds/json/cve/1.0/nvdcve-1.0-recent.json.gz");
    store.set("mitre.last_update", "");

    store.set("cpe.data_url", "https://nvd.nist.gov/feeds/xml/cpe/dictionary/official-cpe-dictionary_v2.3.xml.gz");
    store.set("cpe.last_update", "");

    store.set("cpe.data_url", "https://nvd.nist.gov/feeds/xml/cpe/dictionary/official-cpe-dictionary_v2.3.xml.gz");
    store.set("cpe.last_update", "");
    store.set("cpe.last_update_check", "");
  }
}

// Quit when all windows are closed.
app.on('window-all-closed', () => {
  // On macOS it is common for applications and their menu bar
  // to stay active until the user quits explicitly with Cmd + Q
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

app.on('activate', () => {
  // On macOS it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (win === null) {
    createWindow()
  }
})

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', async () => {
  if (isDevelopment && !process.env.IS_TEST) {
    // Install Vue Devtools
    await installVueDevtools()
  }
  createWindow()

  win.webContents.on('did-finish-load', () => {
    // Start-up methods here.
    
    // DONE - Fix bug in Mitre update when scraping CVE data.  row==undefined is not working.
    // Need to check online, if not then set !online and display modal to user 
    // updateConnectionStatus needs a var for timeSinceLastOnlineCheck maybe?
    // Need to handle a scenario where we go offline in the middle of updating data.
    // Need to handle first run offline scenario (disable functionality here and in App)
    // Get errors sending to App modal
    // DONE - Fix NVD Modals with no score not showing
    // DONE - Fix Modal for Mitre view not showing
    // DONE - Close modal on click anywhere not just bg (feed views only)
    // DONE - Create view for inspecting a collection
    // DONE - Get CPE Dictionary downloading, extracted, reparsed, saved to smaller filesize.
    // DONE - Integrate 'live search' from previous code.
    /// DONE - Load (reading) existing collections on statup
    //// DONE - Import new collections (Read file, validate objects, push to current collections array)
    //// DONE - Import a single collection
    // DONE - Get single collection saving to vuex and disk.
    /// DONE - Export all collections
    /// DONE - Export a single collection
    // DONE - Delete a single collection
    /// Delete all collections (why?)
    // DONE - Clearing nvd state when updating analyzed.
    // PARTIAL - Get CVE data for CPE's in collections
    // Consider sending entire NVD recent to vuex instead of individual cve's
    // Consider sending entire Mitre twitter to vuex instead of individual cve's
    // Get NVD checking before Mitre so that xreference (compare to Analyzed) is available to cut back on Mitre tweets scraped/used and NVD scraping.
    // When updating NVD recent copare to old version updating where necessary.
    // If App closed during update, force full update on next start?
    // Test ErrorHandler functionality (Error Modal)
    // When getting CVE data consider getting from different sources (alternating pulls NVD, Mitre, github: CVE JSON project)
    // Convert mitre feed information into NVD CVE JSON format so that reading/writing can be standardized across App
    // Clusterize.js for lists!!
    // Option? -- have NVD archive local (refactor taking into possible local sources)
    // Option -- export to PDF
    updateConnectionStatus() // actually use this at some point
    loadWatchList()
    loadCpeDictToVuex()
/*    checkForCpeUpdate()
    updateNvdData()
    updateMitreData()*/
/*
    // Looping timer: 30m * 60s * 1000ms = 1800000
    setInterval( function () {
      // Add repeating functions here.
      console.log('Running timer events...')
      updateMitreData()
    }, 1800000)

    // Looping timer: 60m * 60s * 1000ms = 1800000
    setInterval( function () {
      // Add repeating functions here.
      console.log('Running timer events...')
      checkForCpeUpdate()
      updateNvdData()
    }, 3600000)
*/
  })

  ipcMain.on('export-watchlist', (event, arg) => {
    exportWatchList(arg)
  })

  ipcMain.on('save-local-watchlist', (event, arg) => {
    saveWatchList(arg)
  })

  ipcMain.on('import-watchlist', () => {
    importWatchList()
  })

  ipcMain.on('req-update-watchlist', (event, arg) => {
    updateWatchlistCve(arg)
  })

  ipcMain.on('getCveInfoFromGit', (event, arg) => {
    getCveInfoFromGit(arg).then(function(html) {
      //console.log(html.body)
      win.webContents.send('info-for-modal', JSON.parse(html.body))
    })
  })
  
})

// Exit cleanly on request from parent process in development mode.
if (isDevelopment) {
  if (process.platform === 'win32') {
    process.on('message', data => {
      if (data === 'graceful-exit') {
        app.quit()
      }
    })
  } else {
    process.on('SIGTERM', () => {
      app.quit()
    })
  }
}

function updateWatchlistCve(object) {
  // {index: this.index, watchlist: this.watchlist}

  var hdone = false
  var adone = false
  var odone = false

  if(object.watchlist.cpes[0].hardware.length === 0) {
    console.log('no hardware cpes')
    hdone = true
    if(hdone == true && adone==true && odone==true)
    {
      console.log('sending object')
      win.webContents.send('res-update-watchlist', object)
    }

  }
  else {
    console.log('got an hardware cpe')
    var hcounter=0
    asyncForEach(object.watchlist.cpes[0].hardware,  async (cpe) => {
      console.log('working on hardware cpe' + hcounter)

      let str = cpe.wfn
      cpe.cves = []
      str = str.replace(/:/g, "%3a")
      str = str.replace(/\//g, "%2f")

      var url = 'https://nvd.nist.gov/products/cpe/search/results?keyword=' + str + '&status=FINAL&orderBy=CPEURI&namingFormat=2.3'
      
      await scrapeWatchlistCpeData(url).then( function(html) {
        var root = parse(html.body)
        var td = root.querySelector('td')
        var row = td.querySelector('.row').querySelector('.col-lg-12').childNodes[5].rawAttributes['href']
        
        url = 'https://nvd.nist.gov' + row
      })
      
      await scrapeWatchlistCpeData(url).then( function(html) {
        var root = parse(html.body)
        var count = /<strong data-testid="vuln-matching-records-count">(.*)<\/strong>/g.exec(root.toString())
        console.log('got hardware cpe' + hcounter + 'cve count')
        // WORKING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // count[1] = number of CVE records.  Failsafe way to determine if there are any cve's and if count is > 20 i know that i have to deal with pagination.
        if(parseInt(count[1]) == 0)
        {
          console.log('hardware cpe' + hcounter + 'has no cves. going to next cpe')
          hcounter++

          if(hcounter === object.watchlist.cpes[0].hardware.length)
          {
            console.log('hardware cpes complete.')
            hdone = true
            if(hdone == true && adone==true && odone==true)
            {
              console.log('sending object.')
              win.webContents.send('res-update-watchlist', object)
            }
          }
        }
        else
        {
          if(parseInt(count[1]) > 20)
          {
            console.log('hardware cpe' + hcounter + ' has more than 20 cves.')
            // getting pagination nav
            var pagination = root.querySelector('.pagination')
            // getting all li in ul
            var li = pagination.querySelectorAll('li')
            // getting first href and removing the 0 to have a base url to work from
            var baseUrl = li[0].querySelector('a').rawAttributes['href'].substring(0, (li[0].querySelector('a').rawAttributes['href'].length - 1))
            // getting last href and splitting to get the last param value
            var lastResultCount = li[li.length - 1].querySelector('a').rawAttributes['href'].split("&startIndex=")
            var urls= []
            for(var i = 0; i < (parseInt(lastResultCount[1])+20); i += 20)
            {
              var _url = 'https://nvd.nist.gov' + baseUrl + i
              urls.push(_url)
            }
            
            // now all needed urls are in urls for scraping
            // proceed to scrap all urls for cpe-id's
            var urlcounter = 0
            asyncForEach(urls, async (url) => {
              await scrapeWatchlistCpeData(url).then(function (html) {
                var root = parse(html.body)
                var table = root.querySelector('table')
                var tbody = table.querySelector('tbody')
                var tr = tbody.querySelectorAll('tr')

                for(var i = 0; i < tr.length; i++)
                {
                  
                  cpe.cves.push(tr[i].querySelector('th').querySelector('strong').querySelector('a').rawText + ' : ' + tr[i].querySelector('td').querySelector('p').rawText)
                  
                }
                console.log('hardware cpe' + hcounter + ' cve scrape ' + urlcounter + '/' + urls.length + 'complete. moving to next url.')
                urlcounter++
              })

              if(urlcounter === urls.length)
              {
                console.log('hardware cpe' + hcounter + ' cve scrape complete. moving to next cpe.')
                hcounter++

                if(hcounter === object.watchlist.cpes[0].hardware.length)
                {
                  console.log('hardware cpes complete.')
                  hdone = true
                  if(hdone == true && adone==true && odone==true)
                  {
                    console.log('sending object.')
                    win.webContents.send('res-update-watchlist', object)
                  }
                }
              }
            })
            
          }
          else
          {
            //scrape this page for cpe-ids
            var table = root.querySelector('table')
            var tbody = table.querySelector('tbody')
            var tr = tbody.querySelectorAll('tr')

            for(var j = 0; j < tr.length; j++)
            {
              cpe.cves.push(tr[j].querySelector('th').querySelector('strong').querySelector('a').rawText + ' : ' + tr[j].querySelector('td').querySelector('p').rawText)
              console.log('hardware cpe' + hcounter + ' cve scrape 1 complete.')
            }

            console.log('hardware cpe' + hcounter + ' cve scrape complete. moving to next cpe.')
            hcounter++
            if(hcounter === object.watchlist.cpes[0].hardware.length)
            {
              console.log('hardware cpes complete.')
              hdone = true
              if(hdone == true && adone==true && odone==true)
              {
                console.log('sending object.')
                win.webContents.send('res-update-watchlist', object)
              }
            }
          }
        }

        
      })
      
      
    })
  }

  if(object.watchlist.cpes[0].applications.length === 0) {
    console.log('no applications cpes')
    adone = true
    if(hdone == true && adone==true && odone==true)
    {
      console.log('sending object')
      win.webContents.send('res-update-watchlist', object)
    }

  }
  else {
    console.log('got an applications cpe')
    var acounter=0
    asyncForEach(object.watchlist.cpes[0].applications,  async (cpe) => {
      console.log('working on applications cpe' + acounter)

      let str = cpe.wfn
      cpe.cves = []
      str = str.replace(/:/g, "%3a")
      str = str.replace(/\//g, "%2f")

      var url = 'https://nvd.nist.gov/products/cpe/search/results?keyword=' + str + '&status=FINAL&orderBy=CPEURI&namingFormat=2.3'
      
      await scrapeWatchlistCpeData(url).then( function(html) {
        var root = parse(html.body)
        var td = root.querySelector('td')
        var row = td.querySelector('.row').querySelector('.col-lg-12').childNodes[5].rawAttributes['href']
        
        url = 'https://nvd.nist.gov' + row
      })
      
      await scrapeWatchlistCpeData(url).then( function(html) {
        var root = parse(html.body)
        var count = /<strong data-testid="vuln-matching-records-count">(.*)<\/strong>/g.exec(root.toString())
        console.log('got applications cpe' + acounter + 'cve count')
        // WORKING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // count[1] = number of CVE records.  Failsafe way to determine if there are any cve's and if count is > 20 i know that i have to deal with pagination.
        if(parseInt(count[1]) == 0)
        {
          console.log('applications cpe' + acounter + 'has no cves. going to next cpe')
          acounter++

          if(acounter === object.watchlist.cpes[0].applications.length)
          {
            console.log('applications cpes complete.')
            adone = true
            if(hdone == true && adone==true && odone==true)
            {
              console.log('sending object.')
              win.webContents.send('res-update-watchlist', object)
            }
          }
        }
        else
        {
          if(parseInt(count[1]) > 20)
          {
            console.log('applications cpe' + acounter + ' has more than 20 cves.')
            // getting pagination nav
            var pagination = root.querySelector('.pagination')
            // getting all li in ul
            var li = pagination.querySelectorAll('li')
            // getting first href and removing the 0 to have a base url to work from
            var baseUrl = li[0].querySelector('a').rawAttributes['href'].substring(0, (li[0].querySelector('a').rawAttributes['href'].length - 1))
            // getting last href and splitting to get the last param value
            var lastResultCount = li[li.length - 1].querySelector('a').rawAttributes['href'].split("&startIndex=")
            var urls= []
            for(var i = 0; i < (parseInt(lastResultCount[1])+20); i += 20)
            {
              var _url = 'https://nvd.nist.gov' + baseUrl + i
              urls.push(_url)
            }
            
            // now all needed urls are in urls for scraping
            // proceed to scrap all urls for cpe-id's
            var urlcounter = 0
            asyncForEach(urls, async (url) => {
              await scrapeWatchlistCpeData(url).then(function (html) {
                var root = parse(html.body)
                var table = root.querySelector('table')
                var tbody = table.querySelector('tbody')
                var tr = tbody.querySelectorAll('tr')

                for(var i = 0; i < tr.length; i++)
                {
                  //console.log(tr[i].querySelector('th').querySelector('strong').querySelector('a').rawText + ' : ' + tr[i].querySelector('td').querySelector('p').rawText)
                  cpe.cves.push(tr[i].querySelector('th').querySelector('strong').querySelector('a').rawText + ' : ' + tr[i].querySelector('td').querySelector('p').rawText) 
                  
                }
                console.log('applications cpe' + acounter + ' cve scrape ' + urlcounter + '/' + urls.length + 'complete. moving to next url.')
                urlcounter++
              })

              if(urlcounter === urls.length)
              {
                console.log('applications cpe' + acounter + ' cve scrape complete. moving to next cpe.')
                acounter++

                if(acounter === object.watchlist.cpes[0].applications.length)
                {
                  console.log('applications cpes complete.')
                  adone = true
                  if(hdone == true && adone==true && odone==true)
                  {
                    console.log('sending object.')
                    win.webContents.send('res-update-watchlist', object)
                  }
                }
              }
            })
            
          }
          else
          {
            //scrape this page for cpe-ids
            var table = root.querySelector('table')
            var tbody = table.querySelector('tbody')
            var tr = tbody.querySelectorAll('tr')

            for(var j = 0; j < tr.length; j++)
            {
              //console.log(tr[j].querySelector('th').querySelector('strong').querySelector('a').rawText + ' : ' + tr[j].querySelector('td').querySelector('p').rawText)
              cpe.cves.push(tr[j].querySelector('th').querySelector('strong').querySelector('a').rawText + ' : ' + tr[j].querySelector('td').querySelector('p').rawText)
              
            }
            console.log('applications cpe' + acounter + ' cve scrape complete. moving to next cpe.')
            acounter++
            if(acounter === object.watchlist.cpes[0].applications.length)
            {
              console.log('applications cpes complete.')
              adone = true
              if(hdone == true && adone==true && odone==true)
              {
                console.log('sending object.')
                win.webContents.send('res-update-watchlist', object)
              }
            }
          }
        }

        
      })
      
      
    })
  }

  if(object.watchlist.cpes[0].os.length === 0) {
    console.log('no os cpes')
    odone = true
    if(hdone == true && adone==true && odone==true)
    {
      console.log('sending object')
      win.webContents.send('res-update-watchlist', object)
    }

  }
  else {
    console.log('got an os cpe')
    var ocounter=0
    asyncForEach(object.watchlist.cpes[0].os,  async (cpe) => {
      console.log('working on os cpe' + ocounter)

      let str = cpe.wfn
      cpe.cves = []
      str = str.replace(/:/g, "%3a")
      str = str.replace(/\//g, "%2f")

      var url = 'https://nvd.nist.gov/products/cpe/search/results?keyword=' + str + '&status=FINAL&orderBy=CPEURI&namingFormat=2.3'
      
      await scrapeWatchlistCpeData(url).then( function(html) {
        var root = parse(html.body)
        var td = root.querySelector('td')
        var row = td.querySelector('.row').querySelector('.col-lg-12').childNodes[5].rawAttributes['href']
        
        url = 'https://nvd.nist.gov' + row
      })
      
      await scrapeWatchlistCpeData(url).then( function(html) {
        var root = parse(html.body)
        var count = /<strong data-testid="vuln-matching-records-count">(.*)<\/strong>/g.exec(root.toString())
        console.log('got os cpe' + ocounter + 'cve count')
        // WORKING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // count[1] = number of CVE records.  Failsafe way to determine if there are any cve's and if count is > 20 i know that i have to deal with pagination.
        if(parseInt(count[1]) == 0)
        {
          console.log('os cpe' + ocounter + 'has no cves. going to next cpe')
          ocounter++

          if(ocounter === object.watchlist.cpes[0].os.length)
          {
            console.log('os cpes complete.')
            odone = true
            if(hdone == true && adone==true && odone==true)
            {
              console.log('sending object.')
              win.webContents.send('res-update-watchlist', object)
            }
          }
        }
        else
        {
          if(parseInt(count[1]) > 20)
          {
            console.log('os cpe' + ocounter + ' has more than 20 cves.')
            // getting pagination nav
            var pagination = root.querySelector('.pagination')
            // getting all li in ul
            var li = pagination.querySelectorAll('li')
            // getting first href and removing the 0 to have a base url to work from
            var baseUrl = li[0].querySelector('a').rawAttributes['href'].substring(0, (li[0].querySelector('a').rawAttributes['href'].length - 1))
            // getting last href and splitting to get the last param value
            var lastResultCount = li[li.length - 1].querySelector('a').rawAttributes['href'].split("&startIndex=")
            var urls= []
            for(var i = 0; i < (parseInt(lastResultCount[1])+20); i += 20)
            {
              var _url = 'https://nvd.nist.gov' + baseUrl + i
              urls.push(_url)
            }
            
            // now all needed urls are in urls for scraping
            // proceed to scrap all urls for cpe-id's
            var urlcounter = 0
            asyncForEach(urls, async (url) => {
              await scrapeWatchlistCpeData(url).then(function (html) {
                var root = parse(html.body)
                var table = root.querySelector('table')
                var tbody = table.querySelector('tbody')
                var tr = tbody.querySelectorAll('tr')

                for(var i = 0; i < tr.length; i++)
                {
                  
                  cpe.cves.push(tr[i].querySelector('th').querySelector('strong').querySelector('a').rawText + ' : ' + tr[i].querySelector('td').querySelector('p').rawText)
                  
                }
                console.log('os cpe' + ocounter + ' cve scrape ' + urlcounter + '/' + urls.length + 'complete. moving to next url.')
                urlcounter++
              })

              if(urlcounter === urls.length)
              {
                console.log('os cpe' + ocounter + ' cve scrape complete. moving to next cpe.')
                ocounter++

                if(ocounter === object.watchlist.cpes[0].os.length)
                {
                  console.log('os cpes complete.')
                  odone = true
                  if(hdone == true && adone==true && odone==true)
                  {
                    console.log('sending object.')
                    win.webContents.send('res-update-watchlist', object)
                  }
                }
              }
            })
            
          }
          else
          {
            //scrape this page for cpe-ids
            var table = root.querySelector('table')
            var tbody = table.querySelector('tbody')
            var tr = tbody.querySelectorAll('tr')

            for(var j = 0; j < tr.length; j++)
            {
              cpe.cves.push(tr[j].querySelector('th').querySelector('strong').querySelector('a').rawText + ' : ' + tr[j].querySelector('td').querySelector('p').rawText)
              console.log('os cpe' + ocounter + ' cve scrape 1 complete.')
            }

            console.log('os cpe' + ocounter + ' cve scrape complete. moving to next cpe.')
            ocounter++
            if(ocounter === object.watchlist.cpes[0].os.length)
            {
              console.log('os cpes complete.')
              odone = true
              if(hdone == true && adone==true && odone==true)
              {
                console.log('sending object.')
                win.webContents.send('res-update-watchlist', object)
              }
            }
          }
        }

        
      })
      
      
    })
  }

 

}

function getCveInfoFromGit(cveId) {
  return new Promise( function (resolve, reject) {
    request
    .get('https://olbat.github.io/nvdcve/' + cveId + '.json', function(err, body) {
      if (err) {
        console.log(err)
        reject(err);
      }
      else
        resolve(body)
    })
  })
}

function scrapeWatchlistCpeData(url) {
  return new Promise( function (resolve, reject) {
      request
      .get(url, function(err, body) {
        if (err) {
          console.log(err)
          reject(err);
        }
        else
          resolve(body)
      })
  })
}

function sendCpeItem(item) {
  return new Promise(function(resolve) {
    setTimeout(() => {
      win.webContents.send('addCpeItem', item)
    resolve()
  }, 20)
  });
}

async function loadCpeDictToVuex() {
  //console.log('Started dump to Vuex: ' + new Date().toLocaleTimeString())
  //win.webContents.send('updatingCpe', 'Updating CPE store.')

  try{
  var cpeDict = JSON.parse(
    fs.readFileSync(
      app.getPath("userData") + "/cpe-dictionary_v2.3.json"
    )
  )}catch(err) {
    console.log('cpe not found')
    return
  }

  sendCpeItem(await cpeDict)
}

async function checkForCpeUpdate() {
  var last_update
  await scrapeCpeDate().then( function(html) { 
    var root = parse(html.body)

    var str = root.querySelectorAll('ol')[1].querySelectorAll('li')[0].rawText
    last_update = str.split(',')[2].trim()
  })

  if(store.get("cpe.last_update") != last_update)
  {
    //win.webContents.send('updateAvailableForCpe', 'Cpe has an update.')
    updateCpeData()
  }
}

async function updateCpeData() {
  //win.webContents.send('updatingCpe', 'Updating CPE data.')
  console.log('Started file prep: ' + new Date().toLocaleTimeString())
  await getFile(store.get("cpe.data_url"), app.getPath("userData") + "/official-cpe-dictionary_v2.3.xml.gz")
  await extractArchive(app.getPath("userData") + "/official-cpe-dictionary_v2.3.xml.gz");


  var _cpes = []
  var fileStream = fs.createReadStream(app.getPath("userData") + "/official-cpe-dictionary_v2.3.xml", {encoding: "utf8"})
  var saxParser  = sax.createStream(true);
  var streamer   = new saxpath.SaXPath(saxParser, '//cpe-item');

  streamer.on('match', function(xml) {
    xml2js.parseString(xml, {explicitChildren: true}, function (err, result) {
      if(err) return console.log(err)

      var cpe = {
        name: '',
        wfn: ''
      }
        
      if(result['cpe-item'].$.deprecated == undefined) {
        if(result['cpe-item'].$$.title.length > 1) {
          if(result['cpe-item'].$$.title[0].$['xml:lang'] == 'en-US')
            cpe.name = result['cpe-item'].$$.title[0]._ //console.log(result['cpe-item'].$$.title[0]._)
          else if(result['cpe-item'].$$.title[1].$['xml:lang'] == 'en-US')
            cpe.name = result['cpe-item'].$$.title[1]._ //console.log(result['cpe-item'].$$.title[1]._)
        }
        else
          cpe.name = result['cpe-item'].$$.title[0]._ //console.log(result['cpe-item'].$$.title[0]._)

        cpe.wfn = result['cpe-item'].$$['cpe-23:cpe23-item'][0].$.name //console.log(result['cpe-item'].$$['cpe-23:cpe23-item'][0].$.name)
        _cpes.push(cpe)
      }
      else
        return
    })
  });

  streamer.on('end', function () {
    fs.writeFile(app.getPath("userData") + "/cpe-dictionary_v2.3.json", JSON.stringify(_cpes), function(err) {
      if(err) return console.log(err);

      console.log("The file was saved!");
    });

    var last_update
    scrapeCpeDate().then( function(html) { 
      var root = parse(html.body)

      var str = root.querySelectorAll('ol')[1].querySelectorAll('li')[0].rawText
      last_update = str.split(',')[2].trim()

      store.set("cpe.last_update", last_update)
      win.webContents.send('updateCpeLastUpdate', last_update)
      console.log('End file prep: ' + new Date().toLocaleTimeString())
      loadCpeDictToVuex()
    })
  })
      
  fileStream.pipe(saxParser);

  // 0     1     2       3         4         5        6         7         8           9           10          11        12
  //cpe : 2.3 : part : vendor : product : version : update : edition : language : sw_edition : target_sw : target_hw : other
}

function scrapeCpeDate() {
  return new Promise( function (resolve, reject) {
      request
      .get('https://nvd.nist.gov/products/cpe', function(err, body) {
        if (err) {
          console.log(err)
          reject(err);
        }
        else
          resolve(body)
      })
  })
}

async function exportWatchList(data) {
  dialog.showSaveDialog({title: 'Export Watch List(s)', filters: [{name: 'CVE WatchList', extensions: ['cwl']}]}, function(filepath) {
    if(filepath) {
      fs.writeFile(filepath, JSON.stringify(data), function(err) {
        if(err)
          return console.log(err)
      })
    }
  })
}

async function saveWatchList(data) {
  
      fs.writeFile(app.getPath("userData") + "/watchlists.json", JSON.stringify(data), function(err) {
        if(err)
          return console.log(err)
      })

}

async function loadWatchList() {
  
  if(fs.existsSync(app.getPath("userData") + "/watchlists.json"))
  {
      fs.readFile(app.getPath("userData") + "/watchlists.json", function(err, data) {
        if(err)
          return console.log(err)

        win.webContents.send('importWatchList', JSON.parse(data))
      })
    }
}

async function importWatchList() {
  dialog.showOpenDialog({title: 'Import Watch List(s)', properties:['openFile'], filters: [{name: 'CVE WatchList', extensions: ['cwl']}]}, function(filepath) {
    if(filepath) {
      console.log(filepath[0])
      fs.readFile(filepath[0], function(err, data) {
        if(err)
          return console.log(err)

        win.webContents.send('importWatchList', JSON.parse(data))
      })
    }
  })
}

async function updateMitreData() {
  win.webContents.send('updatingMitre', 'Updating Mitre data.')

  var _baseUrl = 'https://twitter.com/i/profiles/show/cvenew/timeline/tweets?include_available_features=1&include_entities=1&reset_error_state=false'
  var maxPosition = 0;
  var url
  var timesToLoop = 1;
  var cveToCheck = []

  for(let i = 0; i < timesToLoop; i++) {
    if(maxPosition === 0)
      url = _baseUrl
    else
      url = _baseUrl + '&max_position=' + maxPosition

    await scrapeTwitter(url)

    var twitterdata = JSON.parse(
      fs.readFileSync(
        app.getPath("userData") + "/twitter.json"
      )
    )

    var root = parse(twitterdata.items_html)

    asyncForEach(root.querySelectorAll('.tweet'), async (item) => {
      var position = item.rawAttributes['data-tweet-id']

      if(maxPosition === 0 || maxPosition > position)
        maxPosition = position

      var str = item.querySelector('.content').querySelector('.js-tweet-text-container').text.split(' ')
      cveToCheck.push(str[2])
    })
  }

  var counter = 0
  asyncForEach(cveToCheck, async (cve_id) => {
    await scrapeCve(cve_id).then(function(html) {

      var cveToSend = []
      var root = parse(html.body)

      var td = root.querySelector('td')

      if(td == null)
        counter++
      else
      {
        var row = td.querySelector('.row')
        
        cveToSend.push(cve_id)

        var str = /<p data-testid="vuln-description">(.*)<\/p>/g.exec(row.toString())
        var cve_description = parse(str[0]).rawText
        cveToSend.push(cve_description)

        var cve_published = row['childNodes'][3].querySelector('.bs-callout')['childNodes'][12].rawText
        var cve_modified = row['childNodes'][3].querySelector('.bs-callout')['childNodes'][18].rawText
        cveToSend.push(cve_published)
        cveToSend.push(cve_modified)

        sendMitreItem(cveToSend)
        counter++
      }
    })

    if(counter === cveToCheck.length) {
      var date = new Date()

      store.set("mitre.last_update", date);
      win.webContents.send('updateMitreLastUpdate', date)
      win.webContents.send('updatingMitre', 'Done updating NVD data.')
    }
  })
}

function sendMitreItem(item) {
  return new Promise(function(resolve) {
    setTimeout(() => {
      win.webContents.send('addMitreItem', item)
    resolve()
  }, 100)
  });
}

function scrapeCve(cve_id) {
  return new Promise(function (resolve, reject) {
    setTimeout(() => {
      request
        .get('https://nvd.nist.gov/vuln/detail/' + cve_id, function(error, body) {
          if(error) {
            errorHandler(error)
            reject()
          }
          else
            resolve(body)
        })
    }, 3000)
  })
}

function scrapeTwitter(url) {
  return new Promise(function (resolve, reject) {
    request
      .get(url, function(error) {
        if(error) {
          errorHandler(error)
          reject()
        }
      })
      .pipe(
        fs.createWriteStream(
          app.getPath('userData') + "/twitter.json"
        )
      )
      .on('finish', resolve)
  })
}

async function updateNvdData() {
  win.webContents.send('updatingNvd', 'Updating NVD data.')
  await getFile(store.get("nvd.meta_url"), app.getPath("userData") + "/nvdcve-1.0-recent.meta")

  var newMetaDate = await firstline(app.getPath("userData") + "/nvdcve-1.0-recent.meta")
  
  if (newMetaDate.trim() != store.get("nvd.last_update")) {
    await getFile(store.get("nvd.data_url"), app.getPath("userData") + "/nvdcve-1.0-recent.json.gz")
    await extractArchive(app.getPath("userData") + "/nvdcve-1.0-recent.json.gz")
  }

  // TODO: Stream this JSON??
  var newrecentdata = JSON.parse(
    fs.readFileSync(
      app.getPath("userData") + "/nvdcve-1.0-recent.json"
    )
  )

  var counter = 0
  asyncForEach(newrecentdata.CVE_Items, async (item) => {
    await sendNvdItem(item).then(counter++)
    if(counter === newrecentdata.CVE_Items.length) {
      store.set("nvd.last_update", newMetaDate.trim());
      var date = new Date()
      win.webContents.send('updateNvdLastUpdate', date)
      win.webContents.send('updatingNvd', 'Done updating NVD data.')
    }
  })
}

function sendNvdItem(item) {
  return new Promise(function(resolve) {
    setTimeout(() => {
      win.webContents.send('addNvdItem', item)
      resolve()
    }, 100)
  })
}

async function asyncForEach(array, callback) {
  for(let index = 0; index < array.length; index++) {
    await callback(array[index], index, array)
  }
}

function extractArchive(filename) {
  return new Promise(function(resolve, reject) {
    var fileContents = fs.createReadStream(filename)
    var writeStream = fs.createWriteStream(filename.slice(0, -3))
    var unzip = zlib.createGunzip()

    fileContents
      .pipe(unzip)
      .pipe(writeStream)
      .on('finish', error => {
        if(error)
        {
          errorHandler(error)
          return reject()
        }
        resolve()
      })
  })
}

function getFile(url, writepath) {
  return new Promise(function (resolve, reject) {
    request
      .get(url, function(error) {
        if(error) {
          errorHandler(error)
          reject()
        }
      })
      .pipe(
        fs.createWriteStream(writepath)
      )
      .on('finish', resolve)
  })
}

async function updateConnectionStatus() {
  internetAvailable({
    timeout: 5000,
    retries: 3
  }).then(() => {
    win.webContents.send('connectionStatusUpdate', true)
  }).catch(() => {
    win.webContents.send('connectionStatusUpdate', false) 
  })
}

function errorHandler(error) {
  console.log(error)
}

